"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _DOMMatrix = _interopRequireDefault(require("./DOMMatrix"));

var _CanvasPattern = _interopRequireDefault(require("./CanvasPattern"));

var _parseColor = _interopRequireDefault(require("parse-color"));

var _cssfontparser = _interopRequireDefault(require("cssfontparser"));

var _TextMetrics = _interopRequireDefault(require("./TextMetrics"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function parseCSSColor(value) {
  var result = (0, _parseColor.default)(value);

  if (result.rgba && result.rgba[3] !== 1) {
    return 'rgba(' + result.rgba.join(', ') + ')';
  }

  if (result.hex) {
    var hex = result.hex; // shorthand #ABC

    if (hex[1] === hex[2] && hex[3] === hex[4] && hex[5] === hex[6]) {
      return "#" + hex[1] + hex[3] + hex[5];
    }

    return result.hex;
  }

  return void 0;
}

var testFuncs = ['setLineDash', 'getLineDash', 'setTransform', 'getTransform', 'getImageData', 'save', 'restore', 'createPattern', 'createRadialGradient', 'addHitRegion', 'arc', 'arcTo', 'beginPath', 'clip', 'closePath', 'scale', 'stroke', 'clearHitRegions', 'clearRect', 'fillRect', 'strokeRect', 'rect', 'resetTransform', 'translate', 'moveTo', 'lineTo', 'bezierCurveTo', 'createLinearGradient', 'ellipse', 'measureText', 'rotate', 'drawImage', 'drawFocusIfNeeded', 'isPointInPath', 'isPointInStroke', 'putImageData', 'strokeText', 'fillText', 'quadraticCurveTo', 'removeHitRegion', 'fill', 'transform', 'scrollPathIntoView', 'createImageData'];
var compositeOperations = ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];

var CanvasRenderingContext2D =
/*#__PURE__*/
function () {
  function CanvasRenderingContext2D(canvas) {
    var _this = this;

    _classCallCheck(this, CanvasRenderingContext2D);

    _defineProperty(this, "_directionStack", ['inherit']);

    _defineProperty(this, "_fillStyleStack", ['#000']);

    _defineProperty(this, "_filterStack", ['none']);

    _defineProperty(this, "_fontStack", ['10px sans-serif']);

    _defineProperty(this, "_globalAlphaStack", [1.0]);

    _defineProperty(this, "_globalCompositeOperationStack", ['source-over']);

    _defineProperty(this, "_imageSmoothingEnabledStack", [true]);

    _defineProperty(this, "_imageSmoothingQualityStack", ['low']);

    _defineProperty(this, "_lineCapStack", ['butt']);

    _defineProperty(this, "_lineDashOffsetStack", [0]);

    _defineProperty(this, "_lineDashStack", [[]]);

    _defineProperty(this, "_lineJoinStack", ['miter']);

    _defineProperty(this, "_lineWidthStack", [1]);

    _defineProperty(this, "_miterLimitStack", [10]);

    _defineProperty(this, "_shadowBlurStack", [0]);

    _defineProperty(this, "_shadowColorStack", ['rgba(0, 0, 0, 0)']);

    _defineProperty(this, "_shadowOffsetXStack", [0]);

    _defineProperty(this, "_shadowOffsetYStack", [0]);

    _defineProperty(this, "_stackIndex", 0);

    _defineProperty(this, "_strokeStyleStack", ['#000']);

    _defineProperty(this, "_textAlignStack", ['start']);

    _defineProperty(this, "_textBaselineStack", ['alphabetic']);

    _defineProperty(this, "_transformStack", [[1, 0, 0, 1, 0, 0]]);

    testFuncs.forEach(function (key) {
      _this[key] = jest.fn(CanvasRenderingContext2D.prototype[key].bind(_this));
    });
    this._canvas = canvas;
  }

  _createClass(CanvasRenderingContext2D, [{
    key: "addHitRegion",
    value: function addHitRegion() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var path = options.path,
          fillRule = options.fillRule,
          id = options.id,
          parentID = options.parentID,
          cursor = options.cursor,
          control = options.control,
          label = options.label,
          role = options.role;
      if (!path && !id) throw new DOMException('ConstraintError', 'Failed to execute \'addHitRegion\' on \'' + this.constructor.name + '\': Both id and control are null.');
      if (fillRule && fillRule !== 'evenodd' && fillRule !== 'nonzero') throw new TypeError('Failed to execute \'addHitRegion\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
    }
  }, {
    key: "arc",
    value: function arc(x, y, radius, startAngle, endAngle) {
      var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      if (arguments.length < 5) throw new TypeError('Failed to execute \'arc\' on \'' + this.constructor.name + '\': 5 arguments required, but only ' + arguments.length + ' present.');

      for (var i = 0; i < 5; i++) {
        if (!Number.isFinite(Number(arguments[i]))) return;
      }

      if (Number(radius) < 0) throw new DOMException('IndexSizeError', 'Failed to execute \'arc\' on \'' + this.constructor.name + '\': The radius provided (' + radius + ') is negative.');
    }
  }, {
    key: "arcTo",
    value: function arcTo(cpx1, cpy1, cpx2, cpy2, radius) {
      if (arguments.length < 5) throw new TypeError('Failed to execute \'arcTo\' on \'' + this.constructor.name + '\': 5 arguments required, but only ' + arguments.length + ' present.');
      var cpx1Result = Number(cpx1);
      var cpy1Result = Number(cpy1);
      var cpx2Result = Number(cpx2);
      var cpy2Result = Number(cpy2);

      if (Number.isFinite(cpx1Result) && Number.isFinite(cpx2Result) && Number.isFinite(cpy1Result) && Number.isFinite(cpy2Result)) {
        var radiusResult = Number(radius);
        if (Number.isFinite(radiusResult) && radiusResult < 0) throw new TypeError('Failed to execute \'arc\' on \'' + this.constructor.name + '\': The radius provided (' + radius + ') is negative.');
      }
    }
  }, {
    key: "beginPath",
    value: function beginPath() {}
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) {
      if (arguments.length < 6) throw new TypeError('Uncaught TypeError: Failed to execute \'bezierCurveTo\' on \'' + this.constructor.name + '\': 6 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "clearHitRegions",
    value: function clearHitRegions() {}
  }, {
    key: "clearRect",
    value: function clearRect(x, y, width, height) {
      if (arguments.length < 4) throw new TypeError('Uncaught TypeError: Failed to execute \'clearRect\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "clip",
    value: function clip(path, fillRule) {
      if (arguments.length === 0) return;
      if (arguments.length === 1) fillRule = 'nonzero';

      if (path instanceof Path2D) {
        fillRule = String(fillRule);
        if (fillRule !== 'nonzero' && fillRule !== 'evenodd') throw new TypeError('Failed to execute \'clip\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
      } else {
        path = String(path);
        if (path !== 'nonzero' && path !== 'evenodd') throw new TypeError('Failed to execute \'clip\' on \'' + this.constructor.name + '\': The provided value \'' + path + '\' is not a valid enum value of type CanvasFillRule.');
      }
    }
  }, {
    key: "closePath",
    value: function closePath() {}
  }, {
    key: "createImageData",
    value: function createImageData(width, height) {
      if (arguments.length < 1) throw new TypeError('Failed to execute \'createImageData\' on \'' + this.constructor.name + '\': 1 argument required, but only 0 present.');else if (arguments.length === 1) {
        if (!(width instanceof ImageData)) throw new TypeError('Failed to execute \'createImageData\' on \'' + this.constructor.name + '\': parameter 1 is not of type \'ImageData\'.');
        var result = new ImageData(width.width, width.height);
        result.data.set(width.data);
        return result;
      } else {
        width = Math.abs(Number(width));
        height = Math.abs(Number(height));
        if (!Number.isFinite(width) || width === 0) throw new TypeError('Failed to execute \'createImageData\' on \'' + this.constructor.name + '\': The source width is 0.');
        if (!Number.isFinite(height) || height === 0) throw new TypeError('Failed to execute \'createImageData\' on \'' + this.constructor.name + '\': The source height is 0.');
        return new ImageData(width, height);
      }
    }
  }, {
    key: "createLinearGradient",
    value: function createLinearGradient(x0, y0, x1, y1) {
      if (arguments.length < 4) throw new TypeError('Failed to execute \'createLinearGradient\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
      if (!Number.isFinite(x0)) throw new TypeError('Failed to execute \'createLinearGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (!Number.isFinite(y0)) throw new TypeError('Failed to execute \'createLinearGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (!Number.isFinite(x1)) throw new TypeError('Failed to execute \'createLinearGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (!Number.isFinite(y1)) throw new TypeError('Failed to execute \'createLinearGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      return new CanvasGradient();
    }
  }, {
    key: "createPattern",
    value: function createPattern(image, type) {
      if (arguments.length === 1) throw new TypeError('Failed to execute \'createPattern\' on \'' + this.constructor.name + '\': 2 arguments required, but only 1 present.');
      if (type === null) type = 'repeat';
      if (type === '') type = 'repeat';

      if (type === 'repeat' || type === 'repeat-x' || type === 'repeat-y' || type === 'no-repeat') {
        if (image instanceof HTMLImageElement) return new _CanvasPattern.default();

        if (image instanceof ImageBitmap) {
          if (image._closed) throw new DOMException('ValidationError', 'DOMException: Failed to execute \'createPattern\' on \'CanvasRenderingContext2D\': The image source is detached.');
          return new _CanvasPattern.default();
        }

        if (image instanceof HTMLVideoElement) return new _CanvasPattern.default();
        if (image instanceof HTMLCanvasElement) return new _CanvasPattern.default();
      } else {
        throw new TypeError('Failed to execute \'createPattern\' on \'' + this.constructor.name + '\': The provided type (\'' + type + '\') is not one of \'repeat\', \'no-repeat\', \'repeat-x\', or \'repeat-y\'.');
      }

      throw new TypeError('Failed to execute \'createPattern\' on \'' + this.constructor.name + '\': The provided value is not of type \'(CSSImageValue or HTMLImageElement or SVGImageElement or HTMLVideoElement or HTMLCanvasElement or ImageBitmap or OffscreenCanvas)\'');
    }
  }, {
    key: "createRadialGradient",
    value: function createRadialGradient(x0, y0, r0, x1, y1, r1) {
      if (arguments.length < 6) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': 6 arguments required, but only ' + arguments.length + ' present.');
      if (!Number.isFinite(x0)) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (!Number.isFinite(y0)) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (!Number.isFinite(r0)) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (!Number.isFinite(x1)) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (!Number.isFinite(y1)) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (!Number.isFinite(r1)) throw new TypeError('Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The provided double value is non-finite.');
      if (r0 < 0) throw new DOMException('DataError', 'Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The r0 provided is less than 0.');
      if (r1 < 0) throw new DOMException('DataError', 'Failed to execute \'createRadialGradient\' on \'' + this.constructor.name + '\': The r0 provided is less than 1.');
      return new CanvasGradient();
    }
  }, {
    key: "drawFocusIfNeeded",
    value: function drawFocusIfNeeded(path, element) {
      if (arguments.length === 0) throw new TypeError('Failed to execute \'drawFocusIfNeeded\' on \'' + this.constructor.name + '\': 1 argument required, but only 0 present.');
      if (arguments.length === 2 && !(path instanceof Path2D)) throw new TypeError('Failed to execute \'drawFocusIfNeeded\' on \'' + this.constructor.name + '\': parameter 1 is not of type \'Path2D\'.');

      if (arguments.length === 1) {
        element = path;
      }

      if (!(element instanceof Element)) throw new TypeError(' Failed to execute \'drawFocusIfNeeded\' on \'' + this.constructor.name + '\': parameter ' + arguments.length + ' is not of type \'Element\'.');
    }
  }, {
    key: "drawImage",
    value: function drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
      if (arguments.length < 3) throw new TypeError('Failed to execute \'drawImage\' on \'' + this.constructor.name + '\': 3 arguments required, but only ' + arguments.length + ' present.');
      if (arguments.length === 4 || arguments.length > 5 && arguments.length < 9) throw new TypeError('Failed to execute \'drawImage\' on \'' + this.constructor.name + '\': Valid arities are: [3, 5, 9], but 4 arguments provided.');
      if (img instanceof HTMLImageElement) return;

      if (img instanceof ImageBitmap) {
        if (img._closed) throw new DOMException('ValidationError', 'DOMException: Failed to execute \'drawImage\' on \'CanvasRenderingContext2D\': The image source is detached.');
        return;
      }

      if (img instanceof HTMLVideoElement) return;
      if (img instanceof HTMLCanvasElement) return;
      throw new TypeError('Failed to execute \'drawImage\' on \'' + this.constructor.name + '\': The provided value is not of type \'(CSSImageValue or HTMLImageElement or SVGImageElement or HTMLVideoElement or HTMLCanvasElement or ImageBitmap or OffscreenCanvas)\'');
    }
  }, {
    key: "ellipse",
    value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) {
      var anticlockwise = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
      if (arguments.length < 7) throw new TypeError('Failed to execute \'ellipse\' on \'' + this.constructor.name + '\': 6 arguments required, but only ' + arguments.length + ' present.');

      for (var i = 0; i < 7; i++) {
        if (!Number.isFinite(Number(arguments[i]))) return;
      }

      if (Number(radiusX) < 0) throw new DOMException('IndexSizeError', 'Failed to execute \'ellipse\' on \'' + this.constructor.name + '\': The major-axis radius provided (' + radiusX + ') is negative.');
      if (Number(radiusY) < 0) throw new DOMException('IndexSizeError', 'Failed to execute \'ellipse\' on \'' + this.constructor.name + '\': The minor-axis radius provided (' + radiusY + ') is negative.');
    }
  }, {
    key: "fill",
    value: function fill(path, fillRule) {
      if (arguments.length === 0) return;
      if (arguments.length === 1) fillRule = 'nonzero';

      if (path instanceof Path2D) {
        fillRule = String(fillRule);
        if (fillRule !== 'nonzero' && fillRule !== 'evenodd') throw new TypeError('Failed to execute \'fill\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
      } else {
        path = String(path);
        if (path !== 'nonzero' && path !== 'evenodd') throw new TypeError('Failed to execute \'fill\' on \'' + this.constructor.name + '\': The provided value \'' + path + '\' is not a valid enum value of type CanvasFillRule.');
      }
    }
  }, {
    key: "fillRect",
    value: function fillRect(x, y, width, height) {
      if (arguments.length < 4) throw new TypeError('Uncaught TypeError: Failed to execute \'fillRect\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "fillText",
    value: function fillText(text, x, y, maxWidth) {
      if (arguments.length < 3) throw new TypeError('Failed to execute \'fillText\' on \'' + this.constructor.name + '\': 3 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "getImageData",
    value: function getImageData() {
      return new ImageData(this._canvas.width, this.canvas.height);
    }
  }, {
    key: "getLineDash",
    value: function getLineDash() {
      return this._lineDashStack[this._stackIndex];
    }
  }, {
    key: "getTransform",
    value: function getTransform() {
      return new _DOMMatrix.default(this._transformStack[this._stackIndex]);
    }
  }, {
    key: "isPointInPath",
    value: function isPointInPath(path, x, y) {
      var fillRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'nonzero';
      if (arguments.length < 2) throw new TypeError('Failed to execute \'isPointInPath\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
      if (arguments.length === 3 && !(path instanceof Path2D)) fillRule = y;
      if (fillRule !== 'nonzero' && fillRule !== 'evenodd') throw new TypeError('Failed to execute \'isPointInPath\' on \'' + this.constructor.name + '\': The provided value \'' + fillRule + '\' is not a valid enum value of type CanvasFillRule.');
      return false; // return false in a mocking environment, unless I can verify a point is actually within the path
    }
  }, {
    key: "isPointInStroke",
    value: function isPointInStroke(path, x, y) {
      var fillRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'nonzero';
      if (arguments.length < 2) throw new TypeError('Failed to execute \'isPointInStroke\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
      return false; // return false in a mocking environment, unless I can verify a point is actually within the path
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      if (arguments.length < 2) throw new TypeError('Uncaught TypeError: Failed to execute \'lineTo\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "measureText",
    value: function measureText(text) {
      if (arguments.length < 1) throw new TypeError('VM5906 pen.js:2 Uncaught TypeError: Failed to execute \'measureText\' on \'' + this.constructor.name + '\': 1 argument required, but only 0 present.');
      return new _TextMetrics.default(String(text));
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      if (arguments.length < 2) throw new TypeError('Uncaught TypeError: Failed to execute \'moveTo\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "putImageData",
    value: function putImageData(data, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      if (arguments.length < 3) throw new TypeError('Failed to execute \'putImageData\' on \'' + this.constructor.name + '\': 3 arguments required, but only ' + arguments.length + ' present.');
      if (arguments.length > 3 && arguments.length < 7) throw new TypeError('Failed to execute \'putImageData\' on \'' + this.constructor.name + '\': Valid arities are: [3, 7], but ' + arguments.length + ' arguments provided.');
      if (!(data instanceof ImageData)) throw new TypeError('Failed to execute \'putImageData\' on \'' + this.constructor.name + '\': parameter 1 is not of type \'ImageData\'.');
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(cpx, cpy, x, y) {
      if (arguments.length < 4) throw new TypeError('Failed to execute \'quadraticCurveTo\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "rect",
    value: function rect(x, y, width, height) {
      if (arguments.length < 4) throw new TypeError('Uncaught TypeError: Failed to execute \'rect\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "removeHitRegion",
    value: function removeHitRegion(id) {
      if (arguments.length < 1) throw new TypeError('Failed to execute \'removeHitRegion\' on \'' + this.constructor.name + '\': 1 argument required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "resetTransform",
    value: function resetTransform() {
      this._transformStack[this._stackIndex][0] = 1;
      this._transformStack[this._stackIndex][1] = 0;
      this._transformStack[this._stackIndex][2] = 0;
      this._transformStack[this._stackIndex][3] = 1;
      this._transformStack[this._stackIndex][4] = 0;
      this._transformStack[this._stackIndex][5] = 0;
    }
  }, {
    key: "restore",
    value: function restore() {
      this._transformStack.pop();

      this._directionStack.pop();

      this._fillStyleStack.pop();

      this._filterStack.pop();

      this._fontStack.pop();

      this._globalAlphaStack.pop();

      this._globalCompositeOperationStack.pop();

      this._imageSmoothingEnabledStack.pop();

      this._imageSmoothingQualityStack.pop();

      this._lineCapStack.pop();

      this._lineDashStack.pop();

      this._lineDashOffsetStack.pop();

      this._lineJoinStack.pop();

      this._lineWidthStack.pop();

      this._miterLimitStack.pop();

      this._shadowBlurStack.pop();

      this._shadowColorStack.pop();

      this._shadowOffsetXStack.pop();

      this._shadowOffsetYStack.pop();

      this._strokeStyleStack.pop();

      this._textAlignStack.pop();

      this._textBaselineStack.pop();

      this._stackIndex -= 1;
    }
  }, {
    key: "rotate",
    value: function rotate(angle) {
      if (arguments.length < 1) throw new TypeError('VM6715 pen.js:2 Uncaught TypeError: Failed to execute \'rotate\' on \'' + this.constructor.name + '\': 1 argument required, but only 0 present.');
      angle = Number(angle);
      if (!Number.isFinite(angle)) return;
      var a = this._transformStack[this._stackIndex][0];
      var b = this._transformStack[this._stackIndex][1];
      var c = this._transformStack[this._stackIndex][2];
      var d = this._transformStack[this._stackIndex][3];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      this._transformStack[this._stackIndex][0] = a * cos + c * sin;
      this._transformStack[this._stackIndex][1] = b * cos + d * sin;
      this._transformStack[this._stackIndex][2] = c * cos - a * sin;
      this._transformStack[this._stackIndex][3] = d * cos - b * sin;
    }
  }, {
    key: "save",
    value: function save() {
      this._transformStack.push(this._transformStack[this._stackIndex]);

      this._directionStack.push(this._directionStack[this._stackIndex]);

      this._fillStyleStack.push(this._fillStyleStack[this._stackIndex]);

      this._filterStack.push(this._filterStack[this._stackIndex]);

      this._fontStack.push(this._fontStack[this._stackIndex]);

      this._globalAlphaStack.push(this._globalAlphaStack[this._stackIndex]);

      this._globalCompositeOperationStack.push(this._globalCompositeOperationStack[this._stackIndex]);

      this._imageSmoothingEnabledStack.push(this._imageSmoothingEnabledStack[this._stackIndex]);

      this._imageSmoothingQualityStack.push(this._imageSmoothingQualityStack[this._stackIndex]);

      this._lineCapStack.push(this._lineCapStack[this._stackIndex]);

      this._lineDashStack.push(this._lineDashStack[this._stackIndex]);

      this._lineDashOffsetStack.push(this._lineDashOffsetStack[this._stackIndex]);

      this._lineJoinStack.push(this._lineJoinStack[this._stackIndex]);

      this._lineWidthStack.push(this._lineWidthStack[this.stackIndex]);

      this._miterLimitStack.push(this._miterLimitStack[this._stackIndex]);

      this._shadowBlurStack.push(this._shadowBlurStack[this._stackIndex]);

      this._shadowColorStack.push(this._shadowColorStack[this._stackIndex]);

      this._shadowOffsetXStack.push(this._shadowOffsetXStack[this._stackIndex]);

      this._shadowOffsetYStack.push(this._shadowOffsetYStack[this._stackIndex]);

      this._strokeStyleStack.push(this._strokeStyleStack[this._stackIndex]);

      this._textAlignStack.push(this._textAlignStack[this._stackIndex]);

      this._textBaselineStack.push(this._textBaselineStack[this._stackIndex]);

      this._stackIndex += 1;
    }
  }, {
    key: "scale",
    value: function scale(x, y) {
      if (arguments.length < 2) throw new TypeError('TypeError: Failed to execute \'scale\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);

      if (Number.isFinite(xResult) && Number.isFinite(yResult)) {
        this._transformStack[this._stackIndex][0] *= xResult;
        this._transformStack[this._stackIndex][1] *= xResult;
        this._transformStack[this._stackIndex][2] *= yResult;
        this._transformStack[this._stackIndex][3] *= yResult;
      }
    }
  }, {
    key: "scrollPathIntoView",
    value: function scrollPathIntoView() {}
  }, {
    key: "setLineDash",
    value: function setLineDash(lineDash) {
      var isSequence = [Array, Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array].reduce(function (left, right) {
        return left || lineDash instanceof right;
      }, false);
      if (!isSequence) throw new TypeError('Failed to execute \'setLineDash\' on \'' + this.constructor.name + '\': The provided value cannot be converted to a sequence.');
      var result = [];

      for (var i = 0; i < lineDash.length; i++) {
        var value = Number(lineDash[i]);

        if (Number.isFinite(value) && value >= 0) {
          result.push(value);
        } else {
          return;
        }
      }

      this._lineDashStack[this._stackIndex] = result.length % 2 === 1 ? result.concat(result) : result;
    }
  }, {
    key: "setTransform",
    value: function setTransform(a, b, c, d, e, f) {
      if (arguments.length === 0) {
        this._transformStack[this._stackIndex][0] = 1;
        this._transformStack[this._stackIndex][1] = 0;
        this._transformStack[this._stackIndex][2] = 0;
        this._transformStack[this._stackIndex][3] = 1;
        this._transformStack[this._stackIndex][4] = 0;
        this._transformStack[this._stackIndex][5] = 0;
        return;
      }

      if (arguments.length === 1) {
        if (a instanceof _DOMMatrix.default) {
          this.currentTransform = a;
        } else {
          throw new TypeError('Failed to execute \'setTransform\' on \'' + this.constructor.name + '\': parameter ' + a + ' (\'transform\') is not an object.');
        }

        return;
      }

      if (arguments.length < 6) throw new TypeError('Failed to execute \'setTransform\' on \'' + this.constructor.name + '\': Valid arities are: [0, 1, 6], but ' + arguments.length + ' arguments provided.');
      a = Number(a);
      b = Number(b);
      c = Number(c);
      d = Number(d);
      e = Number(e);
      f = Number(f);
      if (!Number.isFinite(a)) return;
      if (!Number.isFinite(b)) return;
      if (!Number.isFinite(c)) return;
      if (!Number.isFinite(d)) return;
      if (!Number.isFinite(e)) return;
      if (!Number.isFinite(f)) return;
      this._transformStack[this._stackIndex][0] = a;
      this._transformStack[this._stackIndex][1] = b;
      this._transformStack[this._stackIndex][2] = c;
      this._transformStack[this._stackIndex][3] = d;
      this._transformStack[this._stackIndex][4] = e;
      this._transformStack[this._stackIndex][5] = f;
    }
  }, {
    key: "stroke",
    value: function stroke(path) {
      if (arguments.length > 0 && !(path instanceof Path2D)) throw new TypeError('Failed to execute \'stroke\' on \'' + this.constructor.name + '\': parameter 1 is not of type \'Path2D\'.');
    }
  }, {
    key: "strokeRect",
    value: function strokeRect(x, y, width, height) {
      if (arguments.length < 4) throw new TypeError('Uncaught TypeError: Failed to execute \'strokeRect\' on \'' + this.constructor.name + '\': 4 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "strokeText",
    value: function strokeText(text, x, y, maxWidth) {
      if (arguments.length < 3) throw new TypeError('Failed to execute \'strokeText\' on \'' + this.constructor.name + '\': 3 arguments required, but only ' + arguments.length + ' present.');
    }
  }, {
    key: "transform",
    value: function transform(a, b, c, d, e, f) {
      if (arguments.length < 6) throw new TypeError('Failed to execute \'transform\' on \'' + this.constructor.name + '\': 6 arguments required, but only ' + arguments.length + ' present.');

      for (var i = 0; i < 6; i++) {
        if (!Number.isFinite(Number(arguments[i]))) return;
      }

      a = Number(a);
      b = Number(b);
      c = Number(c);
      d = Number(d);
      e = Number(e);
      f = Number(f);
      var sa = this._transformStack[this._stackIndex][0];
      var sb = this._transformStack[this._stackIndex][1];
      var sc = this._transformStack[this._stackIndex][2];
      var sd = this._transformStack[this._stackIndex][3];
      var se = this._transformStack[this._stackIndex][4];
      var sf = this._transformStack[this._stackIndex][5];
      this._transformStack[this._stackIndex][0] = sa * a + sc * b;
      this._transformStack[this._stackIndex][1] = sb * a + sd * b;
      this._transformStack[this._stackIndex][2] = sa * c + sc * d;
      this._transformStack[this._stackIndex][3] = sb * c + sd * d;
      this._transformStack[this._stackIndex][4] = sa * e + sc * f + se;
      this._transformStack[this._stackIndex][5] = sb * e + sd * f + sf;
    }
  }, {
    key: "translate",
    value: function translate(x, y) {
      if (arguments.length < 2) throw new TypeError('TypeError: Failed to execute \'translate\' on \'' + this.constructor.name + '\': 2 arguments required, but only ' + arguments.length + ' present.');
      var xResult = Number(x);
      var yResult = Number(y);
      var a = this._transformStack[this._stackIndex][0];
      var b = this._transformStack[this._stackIndex][1];
      var c = this._transformStack[this._stackIndex][2];
      var d = this._transformStack[this._stackIndex][3];

      if (Number.isFinite(xResult) && Number.isFinite(yResult)) {
        this._transformStack[this._stackIndex][4] += a * xResult + c * yResult;
        this._transformStack[this._stackIndex][5] += b * xResult + d * yResult;
      }
    }
  }, {
    key: "canvas",
    get: function get() {
      return this._canvas;
    }
  }, {
    key: "currentTransform",
    set: function set(value) {
      if (value instanceof _DOMMatrix.default) {
        this._transformStack[this._stackIndex][0] = value.a;
        this._transformStack[this._stackIndex][1] = value.b;
        this._transformStack[this._stackIndex][2] = value.c;
        this._transformStack[this._stackIndex][3] = value.d;
        this._transformStack[this._stackIndex][4] = value.e;
        this._transformStack[this._stackIndex][5] = value.f;
      }
    },
    get: function get() {
      return new _DOMMatrix.default(this._transformStack[this._stackIndex]);
    }
  }, {
    key: "direction",
    set: function set(value) {
      if (value === 'rtl' || value === 'ltr' || value === 'inherit') {
        this._directionStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._directionStack[this._stackIndex];
    }
  }, {
    key: "fillStyle",
    set: function set(value) {
      if (typeof value === 'string') {
        var result = parseCSSColor(value);

        if (result) {
          this._fillStyleStack[this._stackIndex] = result;
        }
      } else if (value instanceof CanvasGradient || value instanceof _CanvasPattern.default) {
        this._fillStyleStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._fillStyleStack[this._stackIndex];
    }
  }, {
    key: "filter",
    set: function set(value) {
      if (value === '') value = 'none';
      this._filterStack[this._stackIndex] = typeof value === 'string' ? value : 'none';
    },
    get: function get() {
      return this._filterStack[this._stackIndex];
    }
  }, {
    key: "font",
    set: function set(value) {
      var ex;

      try {
        var result = (0, _cssfontparser.default)(value);
        this._fontStack[this._stackIndex] = result.toString();
      } catch (ex) {}
    },
    get: function get() {
      return this._fontStack[this._stackIndex];
    }
  }, {
    key: "globalAlpha",
    set: function set(value) {
      if (!Number.isFinite(value)) return;
      if (value < 0) return;
      if (value > 1) return;
      this._globalAlphaStack[this._stackIndex] = value;
    },
    get: function get() {
      return this._globalAlphaStack[this._stackIndex];
    }
  }, {
    key: "globalCompositeOperation",
    set: function set(value) {
      if (compositeOperations.indexOf(value) !== -1) {
        this._globalCompositeOperationStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._globalCompositeOperationStack[this._stackIndex];
    }
  }, {
    key: "imageSmoothingEnabled",
    set: function set(value) {
      this._imageSmoothingEnabledStack[this._stackIndex] = Boolean(value);
    },
    get: function get() {
      return this._imageSmoothingEnabledStack[this._stackIndex];
    }
  }, {
    key: "imageSmoothingQuality",
    set: function set(value) {
      if (value === 'high' || value === 'medium' || value === 'low') {
        this._imageSmoothingQualityStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._imageSmoothingQualityStack[this._stackIndex];
    }
  }, {
    key: "lineCap",
    set: function set(value) {
      if (value === 'butt' || value === 'round' || value === 'square') {
        this._lineCapStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._lineCapStack[this._stackIndex];
    }
  }, {
    key: "lineDashOffset",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result)) {
        this._lineDashOffsetStack[this._stackIndex] = result;
      }
    },
    get: function get() {
      return this._lineDashOffsetStack[this._stackIndex];
    }
  }, {
    key: "lineJoin",
    set: function set(value) {
      if (value === 'round' || value === 'bevel' || value === 'miter') {
        this._lineJoinStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._lineJoinStack[this._stackIndex];
    }
  }, {
    key: "lineWidth",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result) && result > 0) {
        this._lineWidthStack[this._stackIndex] = result;
      }
    },
    get: function get() {
      return this._lineWidthStack[this._stackIndex];
    }
  }, {
    key: "miterLimit",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result) && result > 0) {
        this._miterLimitStack[this._stackIndex] = result;
      }
    },
    get: function get() {
      return this._miterLimitStack[this._stackIndex];
    }
  }, {
    key: "shadowBlur",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result) && result > 0) {
        this._shadowBlurStack[this._stackIndex] = result;
      }
    },
    get: function get() {
      return this._shadowBlurStack[this._stackIndex];
    }
  }, {
    key: "shadowColor",
    set: function set(value) {
      if (typeof value === 'string') {
        var result = parseCSSColor(value);

        if (result) {
          this._shadowColorStack[this._stackIndex] = result;
        }
      }
    },
    get: function get() {
      return this._shadowColorStack[this._stackIndex];
    }
  }, {
    key: "shadowOffsetX",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result)) {
        this._shadowOffsetXStack[this._stackIndex] = result;
      }
    },
    get: function get() {
      return this._shadowOffsetXStack[this._stackIndex];
    }
  }, {
    key: "shadowOffsetY",
    set: function set(value) {
      var result = Number(value);

      if (Number.isFinite(result)) {
        this._shadowOffsetXStack[this._stackIndex] = result;
      }
    },
    get: function get() {
      return this._shadowOffsetXStack[this._stackIndex];
    }
  }, {
    key: "strokeStyle",
    set: function set(value) {
      if (typeof value === 'string') {
        var result = parseCSSColor(value);

        if (result) {
          this._strokeStyleStack[this._stackIndex] = result;
        }
      } else if (value instanceof CanvasGradient || value instanceof _CanvasPattern.default) {
        this._strokeStyleStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._strokeStyleStack[this._stackIndex];
    }
  }, {
    key: "textAlign",
    set: function set(value) {
      if (value === 'left' || value === 'right' || value === 'center' || value === 'start' || value === 'end') {
        this._textAlignStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._textAlignStack[this._stackIndex];
    }
  }, {
    key: "textBaseline",
    set: function set(value) {
      if (value === 'top' || value === 'hanging' || value === 'middle' || value === 'alphabetic' || value === 'ideographic' || value === 'bottom') {
        this._textBaselineStack[this._stackIndex] = value;
      }
    },
    get: function get() {
      return this._textBaselineStack[this._stackIndex];
    }
  }]);

  return CanvasRenderingContext2D;
}();

exports.default = CanvasRenderingContext2D;